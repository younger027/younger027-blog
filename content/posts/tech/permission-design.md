---
title: "Permission Design"
date: 2023-08-09T17:28:37+08:00
author: ["Younger"] #作者
categories:
- 分类1
- 分类2
tags:
- system-design
- interview
description: "" #描述
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true #是否展示评论
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
image: "" #图片路径：posts/tech/文章1/picture.png
caption: "" #图片底部描述
alt: ""
relative: false
---

### 1. 权限系统设计


### 2. 分布式事务
分布式事务有很多的解决方案，例如2PC，3PC，TCC，MQ补偿等。其中2PC和3PC是强一致性，而其他的都是最终一致性方案。3PC是对2PC的补充，实际应用中并不太会使用，因为实现太复杂，因此只存在理论阶段。而MQ补偿和TCC方式使用的比较多。
- 3PC解决了2PC的什么问题？
  - 3PC新增了第一个阶段canCommit，首先询问参与者是否可能执行任务，各参与者回复yes后，，第二阶段发送preCommit给参与者，其执行任务，执行完成后回复ACK,当所有参与者返回ACK后，发送三阶段Commit给参与者。
  - 此时存在两种情况
    - 1. 当第二阶段超时，协调者宕机，无法发送preCommit，那参与者超时后会回滚。
    - 2. 当第三阶段超时，协调者宕机，无法发送Commit，那参与者超时后会提交事务。
 解决了2pc中假如参与者超时不知是否该提交还是回滚的问题。但是数据不一致的情况还是会有的。

 - 实际使用最多的MQ补偿方案
   - MQ的补偿方案是落地的普遍方案，它主要是牺牲强一致性，达到最终一致性。而且MQ方案还原生的带来了，高并发流量下的流量削峰。
   - 目前是微服务流行的时代，一个事务会历经多个微服务调用，MQ方案完成事务时主要流程是这样的。假如我们有A、B两个微服务，来完成一个事务的流程。A执行完成后，将消息写入MQ，B服务作为消费者消费完这条消息就相当于事务执行完成了。所以我们只要保证：
     - 1.消息写入了MQ
     - 2.MQ不会丢失数据 
     - 3.B服务是否成功消费了这条数据。
  针对1和2，目前主流的MQ都有ack写入确认和其他复制的方式保证MQ不会丢失消息。那么3如何保证呢，其实只要B服务成功消费后，将状态通知到A就可以(可以消费成功后，将消息写入A订阅的mq)。即使出现了消息丢失的情况，系统也还是可以通过定时任务扫描的方式，将未完成的消息重新投递来进行消息补偿。这是基于消息队列实现分布式事务的关键，是一种双向消息确认的机制。